/*
@RestController --> sÄ±nÄ±fÄ± Rest API olarak tanÄ±mlar.
        ---> Controller + ResponseBody bileÅŸimidir
        ---> Methodlardan dÃ¶nen verileri otomatik olarak JSON formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r --> Jackson kÃ¼tÃ¼phanesi ile
        ---> HTTP isteklerini karÅŸÄ±layan sÄ±nÄ±flarda kullanÄ±yoruz.

        4-@RequestMapping --> Methoda ya da Classa gelen HTTP isteklerini eÅŸler
        ---> Method seviyesinde ya da class seviyesinde kullanÄ±lÄ±r
     ---> End point te @RequestMappig("/students") dediÄŸimizde ,url de gidilecek Ã¶zelleÅŸmiÅŸ adresi belirtir.(sÄ±nÄ±f veya method iÃ§in)
        *** Alternnatifler vardÄ±r***
        ---> @GetMapping
     ---> @PutMapping/@PatchMapping
     ---> @PostMapping
     ---> @DeleteMapping


 */

 ---------------

 @ResponseBody anotasyonu, Spring Boot'ta bir metodun dÃ¶nÃ¼ÅŸ deÄŸerinin doÄŸrudan HTTP yanÄ±t gÃ¶vdesine yazÄ±lmasÄ±nÄ±
 saÄŸlar. Yani dÃ¶nÃ¼ÅŸ deÄŸeri, bir view (HTML ÅŸablon) deÄŸil, doÄŸrudan JSON, XML veya dÃ¼z metin gibi bir veri olarak
 istemciye gÃ¶nderilir.

 Ne Ä°ÅŸe Yarar?
 VarsayÄ±lan olarak, Spring bir controller metodunun dÃ¶nÃ¼ÅŸÃ¼nÃ¼ bir view (Ã¶rneÄŸin bir HTML sayfasÄ±) olarak
 yorumlamaya Ã§alÄ±ÅŸÄ±r. Ancak @ResponseBody kullanÄ±ldÄ±ÄŸÄ±nda bu davranÄ±ÅŸ deÄŸiÅŸir ve dÃ¶nÃ¼ÅŸ deÄŸeri serileÅŸtirilerek
 doÄŸrudan HTTP yanÄ±tÄ± olarak gÃ¶nderilir.

 Ne Zaman Gerekir?
 EÄŸer @Controller kullanÄ±yorsan ve bir metottan JSON, XML veya dÃ¼z veri dÃ¶nmek istiyorsan @ResponseBody kullanÄ±rsÄ±n.

 EÄŸer @RestController kullanÄ±yorsan gerekmez, Ã§Ã¼nkÃ¼ zaten varsayÄ±lan olarak aktiftir.

------------------------------------------------------

    @RequestBody, Spring Boot'ta gelen bir HTTP isteÄŸinin gÃ¶vdesindeki veriyi (Ã¶rneÄŸin JSON) alÄ±p, bunu
    otomatik olarak bir Java nesnesine dÃ¶nÃ¼ÅŸtÃ¼rmek (deserialize etmek) iÃ§in kullanÄ±lÄ±r.

    Ne Ä°ÅŸe Yarar?
    Genellikle POST, PUT ve PATCH istekleriyle birlikte kullanÄ±lÄ±r.

    HTTP isteÄŸi gÃ¶vdesindeki JSON (veya XML) veriyi, belirtilen Java sÄ±nÄ±fÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.

    Spring, bu iÅŸlemi HttpMessageConverter aracÄ±lÄ±ÄŸÄ±yla otomatik yapar (genelde Jackson kÃ¼tÃ¼phanesi ile JSON iÃ§in).

    @RequestBody kullandÄ±ÄŸÄ±nda, parametre sÄ±nÄ±fÄ±nÄ±n getter ve setter'larÄ± olmalÄ±dÄ±r, yoksa dÃ¶nÃ¼ÅŸÃ¼m baÅŸarÄ±sÄ±z olur.

    Dikkat Edilecek Noktalar:
    Content-Type baÅŸlÄ±ÄŸÄ± application/json olmalÄ±.

    @RequestBody parametresi boÅŸ geÃ§ilirse (null), varsayÄ±lan olarak 400 Bad Request hatasÄ± dÃ¶ner.

    Anotasyon	Ne iÅŸe yarar?
    @RequestBody	Ä°stek gÃ¶vdesindeki JSON'u Java nesnesine Ã§evirir
    @ResponseBody	Java nesnesini JSON (veya diÄŸer) formata Ã§evirip yanÄ±t olarak dÃ¶ner

    ----------------------------


@RequestMapping("/students") //@RequestMapping, gelen HTTP isteklerini (GET, POST, PUT, DELETE vs.) bir metoda veya controller sÄ±nÄ±fÄ±na yÃ¶nlendirmek iÃ§in kullanÄ±lÄ±r.
                            //Hem sÄ±nÄ±f dÃ¼zeyinde hem de metot dÃ¼zeyinde tanÄ±mlanabilir.

-----------------------
@GetMapping("/greet") //Bu anotasyonla iÅŸaretlenmiÅŸ metodlar, sadece GET tipindeki HTTP isteklerini iÅŸler.
Yani, bir istemci (Ã¶rneÄŸin bir tarayÄ±cÄ± veya frontend uygulamasÄ±) bir URL'ye GET isteÄŸi gÃ¶nderdiÄŸinde, bu anotasyonla iÅŸaretlenmiÅŸ metot Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.

--------------------------------------

  @PostMapping  anotasyonu, bir HTTP POST isteÄŸini belirli bir metoda yÃ¶nlendirmek iÃ§in kullanÄ±lÄ±r.
Genellikle sunucuya veri gÃ¶ndermek veya yeni bir kaynak oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

@RequestParam, @PathVariable, @ModelAttribute gibi diÄŸer anotasyonlarla da kullanÄ±labilir
ama genellikle @RequestBody ile birlikte tercih edilir.

----------------------------------------

@DeleteMapping anotasyonu, bir HTTP DELETE isteÄŸini belirli bir metoda eÅŸlemek iÃ§in kullanÄ±lÄ±r. Bu tÃ¼r istekler
genellikle bir kaynaÄŸÄ± silmek amacÄ±yla yapÄ±lÄ±r â€” Ã¶rneÄŸin veritabanÄ±ndaki bir kaydÄ± silmek gibi.

----------------------------------

 @PatchMapping, Spring Bootâ€™ta HTTP PATCH isteklerini iÅŸlemek iÃ§in kullanÄ±lÄ±r.

    PATCH, bir kaynaÄŸÄ±n tamamÄ±nÄ± deÄŸil, sadece belirli alanlarÄ±nÄ± gÃ¼ncellemek iÃ§in kullanÄ±lÄ±r.

    ğŸ”§ Ne zaman kullanÄ±lÄ±r?
    Bir nesnenin sadece bazÄ± alanlarÄ±nÄ± deÄŸiÅŸtirmek istediÄŸinde (Ã¶rneÄŸin: sadece ad, sadece e-posta).

    PUT gibi tÃ¼m nesneyi deÄŸil, kÄ±smi deÄŸiÅŸiklik yapmak istediÄŸinde

    ----------------------------

    @PutMapping anotasyonu, bir HTTP PUT isteÄŸini belirli bir metoda yÃ¶nlendirmek iÃ§in kullanÄ±lÄ±r.
    Bu istek genellikle bir var olan kaynaÄŸÄ±n tamamÄ±nÄ± gÃ¼ncellemek iÃ§in kullanÄ±lÄ±r.

    PUT ve PATCH ArasÄ±ndaki Fark:
    PUT: KaynaÄŸÄ±n tamamÄ±nÄ± gÃ¼nceller (var olan tÃ¼m alanlarÄ± yeni veriyle deÄŸiÅŸtirir).

    PATCH: KaynaÄŸÄ±n bir kÄ±smÄ±nÄ± gÃ¼nceller (sadece gelen alanlarÄ± deÄŸiÅŸtirir).

    -------------------------------

     @RequestParam

            Spring Boot'ta @RequestParam, bir HTTP isteÄŸi iÃ§indeki query parametrelerini (URLâ€™deki ? sonrasÄ± kÄ±sÄ±mlar) Java metot parametrelerine baÄŸlamak iÃ§in kullanÄ±lÄ±r.
            KÄ±saca: URL'deki parametreleri metoda kolayca almanÄ± saÄŸlar.

                    Ne zaman @RequestParam kullanÄ±lÄ±r?
            âœ… URL query parametreleriyle Ã§alÄ±ÅŸÄ±rken
            âœ… Arama, filtreleme, sÄ±ralama gibi iÅŸlemlerde
            âœ… Formdan gelen verilerde (GET ile gÃ¶nderiliyorsa)

     .

             */


    ----------------------------------

    @PathVariable, bir HTTP isteÄŸi URLâ€™sinin path (yol) kÄ±smÄ±ndaki verileri Java metoduna aktarmak iÃ§in kullanÄ±lÄ±r.
            Yani URLâ€™nin iÃ§ine gÃ¶mÃ¼lÃ¼ veriyi almanÄ± saÄŸlar.

                     Anotasyonun Ã–zellikleri

            Ã–zellik	        AÃ§Ä±klama
            @PathVariable	URL iÃ§indeki {}  sÃ¼slÃ¼ parantezli path verilerini Ã§eker.
            value	        URLâ€™deki deÄŸiÅŸken ismi. Genelde yazmaya bile gerek yoktur.
            required	     VarsayÄ±lan true â€“ yoksa hata verir.


            ğŸ”¸ @PathVariable vs @RequestParam

    Ã–zellik	                @PathVariable	                                   @RequestParam
    Nereden veri alÄ±r?	    URL yolundan (/.../{id})	                  URL query'sinden (?id=...)
    KullanÄ±m amacÄ±	        Kaynak kimliÄŸi, yÃ¶nlendirme	                  Filtreleme, sÄ±ralama, arama
    URL Ã–rneÄŸi	            /students/5	                                  /students?id=5

---------------------------------


    @CrossOrigin anotasyonu, CORS (Cross-Origin Resource Sharing) politikasÄ± ile ilgili ayarlarÄ± kontrol eder.
    BaÅŸka bir deyiÅŸle, farklÄ± bir domainâ€™den (orijin) gelen web isteklerine eriÅŸim izni vermek iÃ§in kullanÄ±lÄ±r.

    Neden Gerekli?
    Modern tarayÄ±cÄ±lar gÃ¼venlik nedeniyle, bir frontend uygulamasÄ±nÄ±n farklÄ± bir domain veya port Ã¼zerinden gelen
    API isteklerini engeller. Buna CORS hatasÄ± denir.

    Ã–rneÄŸin:

    Frontend: http://localhost:3000 (React)

    Backend: http://localhost:8080 (Spring Boot)

    Bu durumda frontend, backend'e doÄŸrudan istek atamazsa CORS policy hatasÄ± alÄ±r.

    Temel KullanÄ±mÄ±:
    java
    Copy
    Edit
    @RestController
    @CrossOrigin(origins = "http://localhost:3000")
    public class UserController {

        @GetMapping("/users")
        public List<User> getUsers() {
            return userService.getAll();
        }
    }
    Bu Ã¶rnekte:

    http://localhost:3000 adresinden gelen istekler kabul edilir.

    TÃ¼m metotlar iÃ§in geÃ§erlidir (Ã§Ã¼nkÃ¼ sÄ±nÄ±f seviyesinde tanÄ±mlanmÄ±ÅŸ).

    Metot Seviyesinde KullanÄ±m:

    @GetMapping("/products")
    @CrossOrigin(origins = "https://example.com")
    public List<Product> getProducts() {
        return productService.getAll();
    }
    YalnÄ±zca bu metoda Ã¶zel izin verir.

    GeliÅŸmiÅŸ KullanÄ±m:

    @CrossOrigin(
        origins = "http://localhost:3000",
        methods = {RequestMethod.GET, RequestMethod.POST},
        allowedHeaders = "*"
    )
    methods: Hangi HTTP metotlarÄ±na izin verileceÄŸini belirtir.

    allowedHeaders: Ä°zin verilen header bilgilerini belirtir (* = hepsi).

    TÃ¼m Uygulamaya CORS AyarÄ± (Global):


    @Configuration
    public class CorsConfig {

        @Bean
        public WebMvcConfigurer corsConfigurer() {
            return new WebMvcConfigurer() {
                @Override
                public void addCorsMappings(CorsRegistry registry) {
                    registry.addMapping("/**")
                            .allowedOrigins("http://localhost:3000")
                            .allowedMethods("*");
                }
            };
        }
    }
    Bu, tÃ¼m controller'lar iÃ§in geÃ§erli olur.

    Ã–zet:

    KullanÄ±m	AÃ§Ä±klama
    @CrossOrigin	Belirli endpoint ya da controllerâ€™a dÄ±ÅŸ isteklere izin verir
    Global Config	TÃ¼m uygulama iÃ§in genel CORS politikasÄ± tanÄ±mlar







